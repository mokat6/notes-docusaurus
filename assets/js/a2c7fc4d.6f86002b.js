"use strict";(globalThis.webpackChunkdoctrex=globalThis.webpackChunkdoctrex||[]).push([[405],{8453:(n,e,s)=>{s.d(e,{R:()=>o,x:()=>a});var t=s(6540);const c={},r=t.createContext(c);function o(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:o(n.components),t.createElement(r.Provider,{value:e},n.children)}},8689:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"async","title":"async","description":"3 states","source":"@site/js/async.md","sourceDirName":".","slug":"/async","permalink":"/notes-docusaurus/js/async","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","next":{"title":"Fetch","permalink":"/notes-docusaurus/js/fetch"}}');var c=s(4848),r=s(8453);const o={},a="async vs .then",i={},l=[];function d(n){const e={br:"br",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.p,{children:"3 states"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"pending, OG"}),"\n",(0,c.jsx)(e.li,{children:"fulfilled, resolve(value) called"}),"\n",(0,c.jsx)(e.li,{children:"rejected, reject(errorMsg?) called"}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["you can chain ",(0,c.jsx)(e.code,{children:".then"}),"s"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'fetchUser()\n  .then((user) => fetchPostsBy(user.id))\n  .then((posts) => filterInteresting(posts))\n  .then((filtered) => console.log(filtered))\n  .catch((err) => console.error("Something failed:", err));\n'})}),"\n",(0,c.jsx)(e.p,{children:"each then returns a promise. if you return a promise yourself, like return value of a function call, then it is awaited.\n.then() always returns a new promise \u2014 even if you return a plain value."}),"\n",(0,c.jsx)(e.p,{children:".catch() handles any rejection or thrown error that happens in the chain before it \u2014 including both the original promise executor and any .then() callbacks."}),"\n",(0,c.jsx)(e.p,{children:"setTimeout returns a number, and it is callback based. You can make it promise based"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n"})}),"\n",(0,c.jsxs)(e.p,{children:["An async function always returns a promise.",(0,c.jsx)(e.br,{}),"\n",'An async function starts execution synchronously, until it hits the first "await" then it stops and returns a pending promise.']}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'const assFunc = async () => {\n  console.log("one");\n  await sleep(666);\n  console.log("two");\n  const bb = await 1;\n  // const cc = await 1;\n};\n'})}),"\n",(0,c.jsx)(e.header,{children:(0,c.jsx)(e.h1,{id:"async-vs-then",children:"async vs .then"})}),"\n",(0,c.jsxs)(e.p,{children:["inside an async function, each ",(0,c.jsx)(e.code,{children:"await"})," corresponds to one chain link of ",(0,c.jsx)(e.code,{children:".then"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'  const sleep = (ms: number) => new Promise<void>((resolve) => setTimeout(resolve, ms));\n\n  const workFromHome = async () => {\n    console.log("one");\n    await sleep(5000);\n    console.log("two");\n    const bb = await 1;\n    const cc = await 1;\n    console.log("cc is ", cc);\n    return "lol no more";\n  };\n'})}),"\n",(0,c.jsx)(e.p,{children:"same as"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'const workFromHomeThenFlat = () => {\n  console.log("one");\n\n  return sleep(5000)\n    .then(() => {\n      console.log("two");\n      return 1;\n    })\n    .then((bb) => 1)\n    .then((cc) => {\n      console.log("cc is", cc);\n      return "lol no more";\n    });\n};\n'})}),"\n",(0,c.jsxs)(e.p,{children:["All async functions return a promise. But a function doesn't have to be marked with ",(0,c.jsx)(e.code,{children:"async"})," to return a promise"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const f1 = async () => 42; // returns Promise<42>\nconst f2 = () => Promise.resolve(42); // same thing\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:".then"})," and Promises were first introduced in ES2015 (ES6)",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)(e.code,{children:"async await"})," is just syntactic sugar, introduced in ES2017, ES8, 2017"]}),"\n",(0,c.jsx)(e.h1,{id:"react",children:"React"}),"\n",(0,c.jsxs)(e.p,{children:["In React you don't really care about the return value of your ",(0,c.jsx)(e.code,{children:"async"})," function. You just setState() in the async function and it returns Promise resolved undefined."]}),"\n",(0,c.jsx)(e.h1,{id:"local-variables",children:"Local variables"}),"\n",(0,c.jsxs)(e.p,{children:["if you declare local variable in a ",(0,c.jsx)(e.code,{children:".then"})," block"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:".then((x) => {\n    const cc = 34;\n    return x.json()\n})\n.then()\n"})}),"\n",(0,c.jsxs)(e.p,{children:["It is not gonna be available in the second ",(0,c.jsx)(e.code,{children:".then"})," block"]}),"\n",(0,c.jsxs)(e.p,{children:["You can define ",(0,c.jsx)(e.code,{children:"let cc"})," in the main function.",(0,c.jsx)(e.br,{}),"\n","You can use ",(0,c.jsx)(e.code,{children:".then"})," syntax, but nested, not flattened, then works.",(0,c.jsx)(e.br,{}),"\n","You can just use async function, then it just works."]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(d,{...n})}):d(n)}}}]);